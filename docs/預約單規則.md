# TaxiGo 預約單規則

## 1. 轉即時單的規則

### 自動轉換機制
- **觸發時間**：預約時間前 20 分鐘自動轉換為即時單
- **檢查頻率**：系統每 1 分鐘檢查一次待轉換的預約單
- **轉換條件**：
  - 訂單類型必須為「預約單」(`OrderTypeScheduled`)
  - 訂單狀態必須為「等待接單」(`OrderStatusWaiting`)
  - 預約時間距離當前時間小於等於 20 分鐘

### 轉換流程
1. **更新訂單類型**：預約單 → 即時單
2. **保持原始狀態**：維持「等待接單」狀態，等待司機接受
3. **通知機制**：
   - 更新原始 Discord 卡片顯示轉換狀態
   - 發送轉換通知訊息說明原因
   - 將轉換後的即時單加入派單隊列
4. **原子操作**：使用 MongoDB 條件更新確保並發安全

### 不會轉換的情況
- 預約單已被司機接受（狀態不為等待接單）
- 預約單已被取消或完成
- 預約時間已過期

## 2. 接預約單後與即時單的互動規則

### 重要發現：接預約單後仍可接即時單
**實際情況與預期不同**：司機接受預約單後，在預約時間到達前的等待期間，**仍然可以接受和執行即時單**。

### 實際的互動規則

#### 預約單接單流程
1. **接受預約單**：
   - 司機狀態：閒置 → 預約單被接受 
   - 設置 `CurrentOrderScheduleId` 綁定預約單
   - **重要**：此時司機仍可接受即時單（系統未阻擋）

2. **接即時單執行**：
   - 司機可正常接受即時單並執行
   - 預約單狀態保持不變，繼續等待激活時間
   - `CurrentOrderScheduleId` 依然綁定原預約單

3. **即時單完成**：
   - 司機狀態重置為「閒置」
   - **關鍵問題**：`CurrentOrderScheduleId` **不會被清除**
   - 預約單綁定關係依然存在

#### 預約單限制檢查
**僅限於預約單接單**：只有在接受新預約單時，系統才會檢查 `CurrentOrderScheduleId`：
```go
// 只在 AcceptScheduledOrder 中檢查
if driver.CurrentOrderScheduleId != nil && *driver.CurrentOrderScheduleId != "" {
    return fmt.Errorf("司機已有預約訂單，無法接新單")
}
```

**即時單無限制**：`AcceptOrder` 方法中沒有檢查 `CurrentOrderScheduleId`，因此不受影響。

### 訂單完成的清理邏輯

#### 預約單完成
- 執行 `ResetDriverScheduledOrder()` 清除 `CurrentOrderScheduleId`
- 司機狀態重置為「閒置」
- 完全解除所有綁定關係

#### 即時單完成
- **只重置司機狀態**為「閒置」
- **不清除** `CurrentOrderScheduleId` 
- 預約單綁定關係依然存在

### 實際使用場景

#### 典型流程
1. 司機接受兩小時後的預約單
2. 在等待期間接受並完成多個即時單
3. 每次即時單完成，司機狀態重置但預約單保持綁定
4. 預約時間到達前 20 分鐘，預約單自動轉為即時單
5. 司機激活並執行原預約單
6. 完成預約單時才真正清除綁定關係

#### 衝突情況
- **無法接新預約單**：由於 `CurrentOrderScheduleId` 仍綁定，無法接受其他預約單
- **可以正常接即時單**：即時單接單不受預約單綁定影響
- **預約單不受即時單影響**：即時單的執行和完成不會影響原預約單狀態

## 3. 預約單列表查詢的限制

### 查詢條件
- **訂單類型**：只顯示預約單 (`OrderTypeScheduled`)
- **分配狀態**：只顯示未分配司機的預約單 (`driver.assigned_driver` 為空)
- **訂單狀態**：只顯示等待接單的預約單 (`OrderStatusWaiting`)
- **時間範圍**：昨天 00:00 到明天 00:00 (UTC 時區)

### 過濾機制
- **車隊過濾**：支援按司機所屬車隊過濾預約單
- **分頁查詢**：支援分頁顯示，避免一次載入過多資料
- **數量統計**：提供總數和按車隊的數量統計

### 查詢 API
- `GetScheduleOrders()`: 分頁查詢預約單列表
- `GetScheduleOrderCount()`: 獲取可接預約單總數
- `GetScheduleOrderCountByFleet()`: 按車隊獲取預約單數量

### 不會顯示的預約單
- 已被其他司機接受的預約單
- 預約時間已過且未轉為即時單的預約單
- 狀態不為等待接單的預約單
- 超出時間範圍的預約單

## 4. 訂單完成的優先級處理

### 基本原則
**司機可以同時綁定一張預約單並執行即時單**。預約單在未激活前不阻止即時單的接受和執行，但同時只能綁定一張預約單。

### 狀態管理規則

#### 預約單狀態流程
1. **等待接單** → 司機可查看並接受
2. **預約單被接受** → 司機被鎖定，無法接其他訂單
3. **激活/轉即時單** → 按即時單流程處理
4. **前往上車點** → 正常訂單執行流程
5. **完成** → 司機狀態重置為閒置

#### 即時單狀態流程
1. **等待接單** → 司機可接受（若無預約單）
2. **前往上車點** → 正常執行流程
3. **完成** → 司機狀態重置為閒置

### 衝突處理機制

#### 預約單 vs 即時單
- **預約單優先**：司機接受預約單後，系統會阻止接受即時單
- **狀態檢查**：接單前檢查 `CurrentOrderScheduleId` 是否為空
- **原子操作**：使用資料庫條件更新防止併發衝突

#### 多預約單衝突
- **單一預約單**：司機同時只能接受一張預約單
- **接單檢查**：接受新預約單前檢查是否已有預約單
- **狀態同步**：預約單狀態與司機狀態保持一致

### 訂單完成優先級

#### 即時單執行中 + 預約單提醒
- **繼續即時單**：完成當前即時單為第一優先
- **預約單等待**：預約單提醒不影響即時單執行
- **自動轉換**：預約單到時間會自動轉為即時單進入派單隊列
- **狀態保持**：預約單綁定關係在即時單完成後依然存在

#### 預約單綁定中 + 新即時單
- **可以接單**：系統允許接受新即時單（與預約單並行）
- **並行處理**：即時單執行不影響預約單狀態
- **自動調度**：預約單到時間仍會正常轉換和激活

#### 預約單激活/執行中 + 新即時單
- **狀態鎖定**：司機狀態為「前往上車點」或「執行任務」時無法接新單
- **專注執行**：司機專心處理當前激活的預約單

### 異常情況處理

#### 訂單取消
- **即時清理**：取消訂單時立即重置司機狀態為閒置
- **解除綁定**：清空 `CurrentOrderScheduleId` 允許接新單
- **通知更新**：更新 Discord/LINE 卡片狀態

#### 系統故障恢復
- **狀態檢查**：系統重啟時檢查司機與訂單狀態一致性
- **自動修復**：發現不一致時記錄日誌並嘗試修復
- **人工介入**：無法自動修復時通知管理員

### 提醒機制

#### 預約單提醒
- **提醒時間**：預約時間前 60 分鐘發送提醒
- **提醒條件**：預約單已被接受且司機尚未收到提醒
- **防重複**：使用 `driver_notified` 欄位防止重複提醒
- **提醒內容**：包含預約時間、上車地點等關鍵資訊

#### 轉換通知
- **轉換提醒**：預約單轉即時單時發送轉換通知
- **說明原因**：告知司機轉換原因（時間即將到達）
- **狀態更新**：同步更新所有相關介面和通知

## 總結

TaxiGo 預約單系統設計確保了：
1. **資料一致性**：司機與訂單狀態嚴格同步
2. **併發安全**：使用原子操作防止狀態衝突
3. **用戶體驗**：自動轉換和提醒機制提升服務效率
4. **系統穩定性**：完善的異常處理和狀態恢復機制

這些規則共同構成了一個完整、可靠的預約單管理系統，確保司機和乘客都能獲得良好的服務體驗。